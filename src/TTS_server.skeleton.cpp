// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

// LPC Net
#include <math.h>
#include "arch.h"
#include "lpcnet.h"
#include "freq.h"

#include <limits.h>
#include <stdio.h>
#include <string.h>

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TServerSocket.h>

#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>


#include <algorithm>
#include <sstream>
#include <iostream>

#include <stdlib.h>
#include "lpc_wave.h"
#include "lpc_utils.h"
#include "TTS.h"

// #include <sys/time.h>
#include <chrono>
#include <time.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace ::something;

class TTSHandler : virtual public TTSIf
{
  private:
    LPCNetState *net;

  public:
    TTSHandler()
    {
        net = lpcnet_create();
    }

    void genAudio(std::string &_return, const std::string &text)
    {
        // auto t1 = std::chrono::high_resolution_clock::now();
        std::cout << "Processing..." << std::endl;
        char output_filename[] = "audio.mp3";
        const int SR = 16000;

        //===================================================================================================
        auto t1 = std::chrono::high_resolution_clock::now();

        // convert string to char
        char cstr[text.size() + 1];
        str2char(text, *cstr);

        auto t2 = std::chrono::high_resolution_clock::now();
        auto duration1 = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1);
        std::cout << "convert string to char --- Time:" << duration1.count() / 1000 << "ms" << std::endl;

        int TACOTRON_FT_LEN = get_length(cstr) + 1;
        float in_features[TACOTRON_FT_LEN];

        //===================================================================================================
        // convert string hex to float
        auto t3 = std::chrono::high_resolution_clock::now();
        int i = 0;
        char *p = strtok(cstr, "|");
        while (p != NULL)
        {
            in_features[i++] = hex2float_(p);
            p = strtok(NULL, "|");
        }

        auto t4 = std::chrono::high_resolution_clock::now();
        auto duration2 = std::chrono::duration_cast<std::chrono::microseconds>(t4 - t3);
        std::cout << "convert string hex to float -- Time:" << duration2.count() / 1000 << "ms" << std::endl;

        //===================================================================================================

        auto t5 = std::chrono::high_resolution_clock::now();
        clock_t start, stop;
        start = clock();

        int PCM_LEN = (TACOTRON_FT_LEN / 20) * 160;
        short full_pcm[PCM_LEN];

        for (int i = 0; i < TACOTRON_FT_LEN; i += (NB_BANDS + 2))
        {
            float features[NB_FEATURES];
            short pcm[FRAME_SIZE];
            RNN_COPY(features, in_features + i, NB_BANDS);
            RNN_CLEAR(&features[18], 18);
            RNN_COPY(features + 36, in_features + i + NB_BANDS, 2);
            // Synthesize
            lpcnet_synthesize(net, pcm, features, FRAME_SIZE);
            RNN_COPY(full_pcm + (i / 20) * 160, pcm, FRAME_SIZE);
        }

        stop = clock();
        printf("synthesize voice -- Time: %.3f\n", ((double)(stop - start) / CLOCKS_PER_SEC));

        auto t6 = std::chrono::high_resolution_clock::now();
        auto duration3 = std::chrono::duration_cast<std::chrono::microseconds>(t6 - t5);
        std::cout << "synthesize voice -- Time:" << duration3.count() / 1000 << "ms" << std::endl;


        //===================================================================================================
        auto t7 = std::chrono::high_resolution_clock::now();
        encodeMP3(full_pcm, PCM_LEN, SR, output_filename);
        // encoderWav(full_pcm, PCM_LEN, output_filename);
        // encodeAAC(full_pcm, PCM_LEN, SR, output_filename);
        auto t8 = std::chrono::high_resolution_clock::now();
        auto duration4 = std::chrono::duration_cast<std::chrono::microseconds>(t8 - t7);
        std::cout << "encode and write audio into disk-- Time:" << duration4.count() / 1000 << "ms" << std::endl;

        //===================================================================================================
        auto t9 = std::chrono::high_resolution_clock::now();
        // Read output filename from disk
        std::ifstream stream(output_filename, std::fstream::binary);
        std::vector<uint8_t> contents((std::istreambuf_iterator<char>(stream)), std::istreambuf_iterator<char>());
        std::string str;
        str.assign(contents.begin(), contents.end());
        std::string outputResult = toHex(str, true);

        auto t10 = std::chrono::high_resolution_clock::now();
        auto duration5 = std::chrono::duration_cast<std::chrono::microseconds>(t10 - t9);
        std::cout << "Read output file from disk - Time:" << duration5.count() / 1000 << "ms" << std::endl;
        //===================================================================================================

        std::cout << "Done" << std::endl;
        std::cout << "===============================================" << std::endl;
        _return = outputResult;
    }
};


int main(int argc, char **argv)
{
    int port = 9101;
    std::cout << "Server is on :" << port << std::endl;

    shared_ptr<TTSHandler> handler(new TTSHandler());
    shared_ptr<TProcessor> processor(new TTSProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();


     // using thread pool with maximum 24 threads to handle incoming requests
    // boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(24);
    // boost::shared_ptr<PosixThreadFactory> threadFactory = boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
    // threadManager->threadFactory(threadFactory);
    // threadManager->start();

    // TNonblockingServer server(processor, protocolFactory, port, threadManager);


    return 0;
}
